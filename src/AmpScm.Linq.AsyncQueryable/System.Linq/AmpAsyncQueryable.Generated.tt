//
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Threading" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".cs" #>
<#
var infoFieldNames = new Dictionary<string, int>();

var toQuoted = default(Func<Type, int, string>);
toQuoted = (t, i) =>
{
    var name = t.Name;

    if (t.IsGenericType)
    {
        var genDef = t.GetGenericTypeDefinition();
        name = genDef.Name.Substring(0, genDef.Name.LastIndexOf('`'));

        var genArgs = "<" + string.Join(", ", t.GetGenericArguments().Select(a => toQuoted(a, i))) + ">";

        if (t.IsValueType && name == "Nullable")
            name = genArgs.Substring(1, genArgs.Length - 2) + "?";
        else
            name += genArgs;
    }
    else if (t.IsArray)
    {
        name = toQuoted(t.GetElementType(), i) + "[]";
    }
    else
    {
        if (t == typeof(int))
            name = "int";
        else if (t == typeof(long))
            name = "long";
        else if (t == typeof(float))
            name = "float";
        else if (t == typeof(double))
            name = "double";
        else if (t == typeof(decimal))
            name = "decimal";
        else if (t == typeof(bool))
            name = "bool";
        else if (t == typeof(object))
            name = "object";
    }

    return name;
};
#>
// This file is autogenerated from it's '.tt' script. Please update this file instead of the generated cs code.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using AmpScm.Linq;

#pragma warning disable RS0041 // Public members should not use oblivious types

namespace System.Linq
{
    partial class AmpAsyncQueryable
    {
<#
    foreach(MethodInfo m in typeof(System.Linq.Queryable).GetMethods(BindingFlags.Public | BindingFlags.Static)
             .Where(x => x.IsGenericMethod && !x.ReturnType.IsValueType)
             .Where(x => typeof(System.Linq.Enumerable).GetMethods(BindingFlags.Public | BindingFlags.Static).Any(y=>y.Name == x.Name))
             .Where(x => x.ReturnType.IsGenericType)

                        .OrderBy(m => m.Name)
                        .ThenBy(m => m.IsGenericMethod ? m.GetGenericArguments().Length : 0)
                        .ThenBy(m => m.GetParameters().Length)
                        .ThenBy(m => string.Join(", ", m.GetParameters().Select((p, i) => toQuoted(p.ParameterType, i) + " " + p.Name))))
    {
        string name = m.Name;
        string returnType = toQuoted(m.ReturnType, 0).Replace("Queryable", "SyncAndAsyncQueryable");
        string typeArgs = "<" + string.Join(", ", m.GetGenericArguments().Select(x=>x.Name)) + ">";
#>
        /// <inheritdoc cref="Queryable.<#=name#><#=typeArgs.Replace("<", "{").Replace(">", "}")#>(<#=
                string.Join(", ",m.GetParameters().Select(p => toQuoted(p.ParameterType, 0).Replace("<", "{").Replace(">", "}")))#>)" />
        public static <#=returnType#> <#=name#><#=typeArgs#>(this <#
            bool first = true;
            foreach (ParameterInfo pi in m.GetParameters())
            {
                if (first)
                    first = false;
                else { #>, <# }

                string typeName = toQuoted(pi.ParameterType, 0).Replace("Queryable", "SyncAndAsyncQueryable");

                string paramName = pi.Name;
                #><#=typeName#> <#=paramName#><#
            }
        #>)
        {
            <#

            string op = "return (" + returnType + ")Queryable." + m.Name + typeArgs + "(" + string.Join(", ", m.GetParameters().Select(x=>x.Name)) + ");";
            #><#=op#>
        }

<#
    }
#>
    }
}
